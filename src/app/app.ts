import { Component, signal, HostListener } from '@angular/core';
import type { WritableSignal } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HeaderComponent } from './components/header/header';
import { Footer } from './components/footer/footer';

@Component({
  selector: 'app-root',
  imports: [FormsModule, HeaderComponent, Footer],
  templateUrl: './app.html',
  styleUrl: './app.css',
})
export class App {
  protected readonly title = signal('text-formatter');

  //variables for processing JSON array
  inputKeywords: string = '';
  outputKeywords: string = '';
  separator: string = ',';
  keywordMessage = signal('');
  private keyWordTimeout?: ReturnType<typeof setTimeout>;
  isBracketsAdded: boolean = true;

  //variables for processing JSON text
  inputParagraph: string = '';
  outputParagraph: string = '';
  replaceMessage = signal('');
  private replaceTimeout?: ReturnType<typeof setTimeout>;

  //variables for storing latest result
  lastResult: string = '';
  lastMessage: WritableSignal<string> | undefined;

  //theme
  isDarkTheme = signal(false);

  ngOnInit() {
    if (typeof localStorage !== 'undefined') {
      const saved = localStorage.getItem('darkMode');
      if (saved) {
        this.isDarkTheme.set(JSON.parse(saved));
        this.applyTheme();
      }
    }
  }

  /**
   * Format string separated by separator (default comma) into JSON Array format
   */
  convertString(): void {
    if (this.inputKeywords) {
      const cleanInput = this.inputKeywords.trim().replace(/^,+|,+$/g, '');
      const processedKeywords = `"${cleanInput
        .split(this.separator)
        .map((item) => item.trim())
        .filter((item) => item.length > 0)
        .join('"\,"')}"`;
      this.outputKeywords = this.isBracketsAdded ? `[${processedKeywords}]` : processedKeywords;
      this.lastMessage = this.keywordMessage;
    } else {
      this.outputKeywords = '';
      this.lastMessage = undefined;
    }
    this.lastResult = this.outputKeywords;
  }

  /**
   * Prepend backslash escape to special characters
   */
  replaceString() {
    if (this.inputParagraph) {
      this.outputParagraph = this.inputParagraph
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\t/g, '\\t')
        .replace(/\r/g, '\\r')
        .replace(/\f/g, '\\f')
        .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, (char) => {
          // Handle remaining control characters (0x00-0x1F except already handled ones)
          // Generated by Claude
          return '\\u' + ('0000' + char.charCodeAt(0).toString(16)).slice(-4);
        });
      this.lastMessage = this.replaceMessage;
    } else {
      this.outputParagraph = '';
      this.lastMessage = undefined;
    }
    this.lastResult = this.outputParagraph;
  }

  /**
   * Copies a string to the clipboard and displays a success message.
   * @param copyString - The string to copy to clipboard
   * @param messageSignal - The signal to update with the success message
   * @returns A promise that resolves when copy operation completes
   * @throws Alert user when copy operation fails
   */
  async copyToClipBoard(copyString: string, messageSignal: WritableSignal<string>): Promise<void> {
    try {
      await navigator.clipboard.writeText(copyString);
      messageSignal.set('copied to clipboard');
      setTimeout(() => {
        messageSignal.set('');
      }, 3000);
    } catch (error) {
      alert('error:' + error);
    }
  }

  /**
   * Debounces keyword input conversion by waiting 1 second after last user input before processing.
   * Cancels any scheduled conversion if user continues input
   */
  debounceKeyword() {
    if (this.keyWordTimeout !== undefined) {
      clearTimeout(this.keyWordTimeout);
    }
    this.keyWordTimeout = setTimeout(() => {
      this.convertString();
      this.keyWordTimeout = undefined;
    }, 1000);
  }

  /**
   * Debounces paragraph input conversion by waiting 1 second after last user input before processing.
   * Cancel any scheduled conversion if user continue input
   */
  debounceReplace() {
    if (this.replaceTimeout !== undefined) {
      clearTimeout(this.replaceTimeout);
    }
    this.replaceTimeout = setTimeout(() => {
      this.replaceString();
      this.replaceTimeout = undefined;
    }, 1000);
  }

  /**
   * Cleans up keyword input and output strings
   */
  clearKeywordInput() {
    if (this.keyWordTimeout !== undefined) {
      clearTimeout(this.keyWordTimeout);
    }
    this.inputKeywords = '';
    this.outputKeywords = '';
  }

  /**
   * Cleans up paragraph input and output strings
   */
  clearParagraphInput() {
    if (this.replaceTimeout !== undefined) {
      clearTimeout(this.replaceTimeout);
    }
    this.inputParagraph = '';
    this.outputParagraph = '';
  }

  /**
   * Auto select text in input/textarea element on click
   */
  selectOutput(event: Event) {
    const target = event.target as HTMLInputElement | HTMLTextAreaElement;
    target.select();
  }

  /**
   * Listens for Ctrl+Enter keystrokes to copy the latest result to clipboard.
   * @param event - The keyboard event
   */
  @HostListener('window:keydown', ['$event'])
  handleCopyHotkey(event: KeyboardEvent) {
    if (event.ctrlKey && event.key === 'Enter') {
      event.preventDefault();
      if (this.lastResult && this.lastMessage) {
        this.copyToClipBoard(this.lastResult, this.lastMessage);
      }
    }
  }

  onThemeChange(newTheme: boolean) {
    this.isDarkTheme.set(newTheme);
    localStorage.setItem('darkMode', JSON.stringify(this.isDarkTheme()));
    this.applyTheme();
  }

  applyTheme() {
    console.log('change theme');
    if (this.isDarkTheme()) {
      document.body.classList.add('dark-mode');
    } else {
      document.body.classList.remove('dark-mode');
    }
  }
}
